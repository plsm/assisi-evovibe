#!/usr/bin/env python
# -*- coding: utf-8 -*-

import config
import arena
import episode
import evaluator
import chromosome
import worker
import continue_inspyred

import assisipy.deploy
import assisipy.assisirun

import inspyred

import argparse
import os
import csv
import random

import worker_settings

FIT_GENERATION = 0
FIT_FITNESS = 1
FIT_CHROMOSOME_GENE = 2

def parse_arguments ():
    """
    Parse the command line arguments.
    """
    parser = argparse.ArgumentParser (
        description = 'Incremental Evolution of vibration models to aggregate bees.',
        argument_default = None
    )
    parser.add_argument (
        '--command', '-c',
        default = None,
        type = str,
        help = 'what should we do?\n\tnew-run: perform a new experimental run\n\tcontinue-run: continue a previous run')
    parser.add_argument (
        '--run', '-r',
        default = None,
        type = int,
        help = "run number to use")
    parser.add_argument (
        '--debug',
        action = 'store_true',
        help = "enable debug mode")
    parser.add_argument (
        '--deploy',
        action = 'store_true',
        help = "deploy the workers automatically")
    parser.add_argument (
        '--workers',
        default = 'workers',
        type = str,
        help = 'worker settings file to load')
    return parser.parse_args ()


def calculate_experiment_folder_for_new_run (args):
    """
    Compute the experiment folder for a new experimental run.
    This folder is where all the files generated by an experimental run are stored.
    """
    run_number = 1
    while True:
        result = 'run-%03d/' % (run_number)
        if args.debug or not os.path.isdir (result) and not os.path.exists (result):
            return result
        run_number += 1

def create_directories_for_experimental_run (experiment_folder, args):
    """
    Create the directories for an experimental run.
    """
    for path in [
            experiment_folder,
            experiment_folder + "logs/",
            experiment_folder + "episodes/"]:
        try:
            os.makedirs (path)
        except:
            if not args.debug:
                raise

def create_experimental_run_files (experiment_folder):
    """
    Create the files that are going to store the data produced by an experimental run.
    The data is stored in CSV files.  The files are initialized with a header row.
    """
    with open (experiment_folder + "population.csv", 'w') as fp:
        f = csv.writer (fp, delimiter = ',', quoting = csv.QUOTE_NONNUMERIC, quotechar = '"')
        row = ["generation", "episode", "chromosome_genes"]
        f.writerow (row)
        fp.close ()
    with open (experiment_folder + "evaluation.csv", 'w') as fp:
        f = csv.writer (fp, delimiter = ',', quoting = csv.QUOTE_NONNUMERIC, quotechar = '"')
        row = ["evaluation", "episode", "iteration", "selected_arena", "active_casu", "value", "chromosome_genes"]
        f.writerow (row)
        fp.close ()
    with open (experiment_folder + "fitness.csv", 'w') as fp:
        f = csv.writer (fp, delimiter = ',', quoting = csv.QUOTE_NONNUMERIC, quotechar = '"')
        row = ["generation", "fitness", "chromosome_genes"]
        f.writerow (row)
        fp.close ()
    with open (experiment_folder + "partial.csv", 'w') as fp:
        f = csv.writer (fp, delimiter = ',', quoting = csv.QUOTE_NONNUMERIC, quotechar = '"')
        row = ["generation", "episode", "fitness", "chromosome_genes"]
        f.writerow (row)
        fp.close ()

def check_run (args):
    run_number = args.run
    result = 'run-%03d/' % (run_number)
    if os.path.isdir (result):
        return result
    else:
        print "There is no run ", run_number
        sys.exit (1)

# def load_population_and_evaluation (config, experiment_folder):
#     with open (experiment_folder + "population.csv", "r") as fp:
#         f = csv.reader (fp, delimiter = ',', quoting = csv.QUOTE_NONNUMERIC, quotechar = '"')
#         f.next () #skip header_row
#         rows = [row for row in f]
#         initial_population = [row [evaluator.POP_CHROMOSOME_GENES:] for row in rows]
#         print (initial_population)
#         current_generation = int (rows [-1][evaluator.POP_GENERATION])
#         current_episode = int (rows [-1][evaluator.POP_EPISODE])
#         s = initial_population [-config.population_size:]
#         seeds = [[int (g) for g in c] for c in s]  # I'm assuming that all genes are integers.
#         fp.close ()
#     with open (experiment_folder + "evaluation.csv", "r") as fp:
#         f = csv.reader (fp, delimiter = ',', quoting = csv.QUOTE_NONNUMERIC, quotechar = '"')
#         f.next () #skip header_row
#         eva_values = []
#         for row in f:
#             if row [evaluator.EVA_GENERATION] == current_generation:
#                 eva_values.append (row [evaluator.EVA_VALUE])
#         eva_values += [None] * (config.population_size * config.number_evaluations_per_chromosome - len (eva_values))
#         fp.close ()
#     return (current_generation, current_episode + 1, seeds, eva_values)

def population_to_continue (config, experiment_folder):
    with open (experiment_folder + "population.csv", "r") as fp:
        f = csv.reader (fp, delimiter = ',', quoting = csv.QUOTE_NONNUMERIC, quotechar = '"')
        f.next () #skip header_row
        rows_population = [row for row in f]
        fp.close ()
    if len (rows_population) > config.population_size:
        population_parents    = [r[evaluator.POP_CHROMOSOME_GENES:] for r in rows_population [-2 * config.population_size:-config.population_size]]
        population_offsprings = [r[evaluator.POP_CHROMOSOME_GENES:] for r in rows_population [-config.population_size:]]
        n = len (population_offsprings [0])
        [c.extend ([random.random () for _ in xrange (n)]) for c in population_offsprings]
    else:
        population_parents    = [r[evaluator.POP_CHROMOSOME_GENES:] for r in rows_population [-config.population_size:]]
        population_offsprings = []
    last_generation = int (rows_population [-1][evaluator.POP_GENERATION])
    return (population_parents, population_offsprings, last_generation)

def fitness_to_continue (config, experiment_folder):
    with open (experiment_folder + "partial.csv", "r") as fp:
        f = csv.reader (fp, delimiter = ',', quoting = csv.QUOTE_NONNUMERIC, quotechar = '"')
        f.next () #skip header_row
        rows_fitness = [row for row in f]
        fp.close ()
    if rows_fitness == []:
        last_generation_number = -1
        last_episode_number = 0
        parents_fitness   = []
        offspring_fitness = []
    else:
        last_generation_number = int (rows_fitness [-1][evaluator.PRT_GENERATION])
        last_episode_number = int (rows_fitness [-1][evaluator.PRT_EPISODE])
        if last_generation_number > 1:
            parents_fitness   = [r[evaluator.PRT_FITNESS] for r in rows_fitness if r[evaluator.PRT_GENERATION] == last_generation_number - 1]
            offspring_fitness = [r[evaluator.PRT_FITNESS] for r in rows_fitness if r[evaluator.PRT_GENERATION] == last_generation_number]
        else:
            parents_fitness   = [r[evaluator.PRT_FITNESS] for r in rows_fitness if r[evaluator.PRT_GENERATION] == last_generation_number]
            offspring_fitness = []
    return (parents_fitness, offspring_fitness, last_generation_number, last_episode_number)

def fitness_save_observer (population, num_generations, num_evaluations, args):
    """
    Observer passed to inspyred evolutionary algorithm to save the data to file fitness.csv.
    """
    config_experiment_folder = args ['config_experiment_folder']
    with open (config_experiment_folder + "fitness.csv", 'a') as fp:
        f = csv.writer (fp, delimiter = ',', quoting = csv.QUOTE_NONE, quotechar = '"')
        for individual in population:
            row = [num_generations, individual.fitness] + individual.candidate
            f.writerow (row)
        fp.close ()

def initialise_data_for_inspyred (config, worker_stubs, experiment_folder, current_generation = 0, episode_index = 1):
    epsd = episode.Episode (config, worker_stubs, experiment_folder, episode_index)
    epsd.initialise ()
    evltr = evaluator.Evaluator (config, epsd, experiment_folder, current_generation)
    evolutionary_algorithm = inspyred.ec.ES (random.Random ())
    evolutionary_algorithm.terminator = [inspyred.ec.terminators.generation_termination]
    evolutionary_algorithm.observer = [fitness_save_observer]
    if config.chromosome_type == "SinglePulseGenePause":
        evolutionary_algorithm.variator = [chromosome.SinglePulseGenePause.get_variator ()]
        generator = chromosome.SinglePulseGenePause.random_generator
    elif config.chromosome_type == "SinglePulseGeneFrequency":
        evolutionary_algorithm.variator = [chromosome.SinglePulseGeneFrequency.get_variator ()]
        generator = chromosome.SinglePulseGeneFrequency.random_generator
    elif config.chromosome_type == "SinglePulseGenesPulse":
        evolutionary_algorithm.variator = [chromosome.SinglePulseGenesPulse.get_variator ()]
        generator = chromosome.SinglePulseGenesPulse.random_generator
    return (epsd, evltr, evolutionary_algorithm, generator)

def new_run (config, worker_stubs, experiment_folder):
    epsd, evltr, evolutionary_algorithm, generator = initialise_data_for_inspyred (config, worker_stubs, experiment_folder)
    evolutionary_algorithm.evolve (
        generator = generator,
        evaluator = evltr.population_evaluator,
        pop_size = config.population_size,
        bounder = None,
        maximize = True,
        max_generations = config.number_generations,
        config_experiment_folder = experiment_folder
    )
    epsd.finish (True)
    for ws in worker_stubs.values ():
        ws.terminate_session ()
    print ("Evolutionary Strategy algorithm finished!")

def continue_run (config, worker_stubs, experiment_folder):
    population_parents, population_offsprings, last_generation_number = population_to_continue (config, experiment_folder)
    parents_fitness, offspring_fitness, _c, last_episode = fitness_to_continue (config, experiment_folder)
    # print "population_parents", population_parents, "\n"
    # print "population_offsprigns", population_offsprings, "\n"
    # print "parents_fitness", parents_fitness, "\n"
    # print "offspring_fitness", offspring_fitness, "\n"
    # print "last_generation_number", last_generation_number
    # print "last_episode", last_episode
    # raw_input ('Press ENTER to continue')
    epsd, evltr, evolutionary_algorithm, generator = initialise_data_for_inspyred (
        config, worker_stubs, experiment_folder,
        last_generation_number - (0 if len (population_parents) == len (parents_fitness) and len (population_offsprings) == 0 else 1),
        last_episode + 1)
    continue_inspyred.continue_evolution (
        evolutionary_algorithm,
        population_parents = population_parents,
        population_offsprings = population_offsprings,
        parents_fitness = parents_fitness,
        offspring_fitness = offspring_fitness,
        generator = generator,
        evaluator = evltr.population_evaluator,
        number_generations = last_generation_number,
        maximize = True,
        bounder = None,
        max_generations = max (0, config.number_generations - last_generation_number),
        config_experiment_folder = experiment_folder
        )
    epsd.finish (True)
    for ws in worker_stubs.values ():
        ws.terminate_session ()
    print ("Evolutionary Strategy algorithm finished!")

# def run_inspyred (config, worker_stubs, experiment_folder, current_generation = 1, episode_index = 1, seeds = None, eva_values = None):
#     """
#     Run the Evolutionary Strategy for the given configuration.
#     """
#     epsd = episode.Episode (config, worker_stubs, experiment_folder, episode_index)
#     epsd.initialise ()
#     es = inspyred.ec.ES (random.Random ())
#     evltr = evaluator.Evaluator (config, epsd, experiment_folder, current_generation, eva_values)
#     es.terminator = [inspyred.ec.terminators.generation_termination]
#     es.observer = [fitness_save_observer]
#     if config.chromosome_type == "SinglePulseGenePause":
#         es.variator = [chromosome.SinglePulseGenePause.get_variator ()]
#         generator = chromosome.SinglePulseGenePause.random_generator
#     elif config.chromosome_type == "SinglePulseGeneFrequency":
#         es.variator = [chromosome.SinglePulseGeneFrequency.get_variator ()]
#         generator = chromosome.SinglePulseGeneFrequency.random_generator
#     elif config.chromosome_type == "SinglePulseGenesPulse":
#         es.variator = [chromosome.SinglePulseGenesPulse.get_variator ()]
#         generator = chromosome.SinglePulseGenesPulse.random_generator
#     es.evolve (
#         generator = generator,
#         evaluator = evltr.population_evaluator,
#         pop_size = config.population_size,
#         bounder = None,
#         maximize = True,
#         max_generations = config.number_generations,
#         seeds = seeds,
#         config_experiment_folder = experiment_folder)
#     print ("\n\n* ** The End")
#     epsd.finish (True)
#     for ws in worker_stubs.values ():
#         ws.terminate_session ()
#     print ("Evolutionary Strategy algorithm finished!")
    
# def run_inspyred_Custom_EC (config, worker_stubs, experiment_folder, current_generation = 1, episode_index = 1, seeds = None, eva_values = None):
#     """
#     Run the Evolutionary Strategy for the given configuration.
#     """
#     epsd = episode.Episode (config, worker_stubs, experiment_folder, episode_index)
#     epsd.initialise ()
#     evocom = inspyred.ec.EvolutionaryComputation (random.Random ())
#     evltr = evaluator.Evaluator (config, epsd, experiment_folder, current_generation, eva_values)
#     evocom.terminator = [inspyred.ec.terminators.generation_termination]
#     evocom.observer = [fitness_save_observer]
#     evocom.replacer = inspyred.ec.replacers.generational_replacement
#     if config.chromosome_type == "SinglePulseGenePause":
#         evocom.variator = [chromosome.SinglePulseGenePause.get_variator ()]
#         generator = chromosome.SinglePulseGenePause.random_generator
#     elif config.chromosome_type == "SinglePulseGeneFrequency":
#         evocom.variator = [chromosome.SinglePulseGeneFrequency.get_variator ()]
#         generator = chromosome.SinglePulseGeneFrequency.random_generator
#     elif config.chromosome_type == "SinglePulseGenesPulse":
#         evocom.variator = [chromosome.SinglePulseGenesPulse.get_variator ()]
#         generator = chromosome.SinglePulseGenesPulse.random_generator
#     evocom.evolve (
#         generator = generator,
#         evaluator = evltr.population_evaluator,
#         pop_size = config.population_size,
#         bounder = None,
#         maximize = True,
#         max_generations = config.number_generations,
#         seeds = seeds,
#         config_experiment_folder = experiment_folder,
#         num_elites = 1 if config.elitism else 0
#     )
#     print ("\n\n* ** The End")
#     epsd.finish (True)
#     for ws in worker_stubs.values ():
#         ws.terminate_session ()
#     print ("Evolutionary Strategy algorithm finished!")

def main ():
    try:
        os.makedirs ("tmp")
    except OSError:
        pass
    args = parse_arguments ()
    if args.command in ['new-run', 'new_run']:
        cfg = config.Config ()
        cfg.status ()
        worker_stubs = dict ([ws.connect_to_worker (cfg) for ws in worker_settings.load_worker_settings (args.workers)])
        # print worker_stubs
        experiment_folder = calculate_experiment_folder_for_new_run (args)
        create_directories_for_experimental_run (experiment_folder, args)
        create_experimental_run_files (experiment_folder)
        new_run (cfg, worker_stubs, experiment_folder)
    elif args.command in ['continue-run', 'continue_run']:
        cfg = config.Config ()
        cfg.status ()
        experiment_folder = check_run (args)
        # current_generation, current_episode, seeds, eva_values = load_population_and_evaluation (cfg, experiment_folder)
        worker_stubs = dict ([ws.connect_to_worker (cfg) for ws in worker_settings.load_worker_settings (args.workers)])
        # print worker_stubs
        continue_run (cfg, worker_stubs, experiment_folder)
    elif args.command in ['deploy']:
        worker_settings.deploy_workers (args.workers, None)
    elif args.command == None:
        print ("Nothing to do!\n")
    else:
        print ("Unknown command: %s" % args.command)

if __name__ == '__main__':
    main ()
